DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

activate_venv
$python buildscripts/collect_resource_info.py -o system_resource_info.json -i 5

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o verbose
set -o errexit
activate_venv
$python buildscripts/evergreen_task_timeout.py \
  --task-name ${task_name} \
  --build-variant ${build_variant} \
  --evg-alias '${alias}' \
  --timeout ${timeout_secs} \
  --exec-timeout ${exec_timeout_secs} \
  --out-file task_timeout_expansions.yml

# exit immediately if virtualenv is not found
set -o errexit

evergreen_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)/.."
. "$evergreen_dir/prelude_workdir.sh"
. "$evergreen_dir/prelude_python.sh"

python_loc=$(which ${python})
venv_dir="${workdir}/../mongodb-mongo-venv"
if [ -d "$venv_dir" ]; then
  exit 0
fi
"$python_loc" -m venv "$venv_dir"

pushd $venv_dir
venv_dir=$(pwd)
popd
cat << EOF >> "$venv_dir/README.txt"
This is an archive of the Python venv generated by this Evergreen build.
You can use it locally to avoid needing to manually set up the Python environment.

Note that Python venv is not relocatable, you must therefore extract this directory to:
$venv_dir
EOF

# venv creates its Scripts/activate file with CLRF endings, which
# cygwin bash does not like. dos2unix it
# (See https://bugs.python.org/issue32451)
if [ "Windows_NT" = "$OS" ]; then
  dos2unix "${workdir}/../mongodb-mongo-venv/Scripts/activate"
fi

export VIRTUAL_ENV_DISABLE_PROMPT=yes

# Not all git get project calls clone into ${workdir}/src so we allow
# callers to tell us where the pip requirements files are.
pip_dir="${pip_dir}"
if [[ -z $pip_dir ]]; then
  # Default to most common location
  pip_dir="${workdir}/src/etc/pip"
fi

# Same as above we have to use quotes to preserve the
# Windows path separator
toolchain_txt="$pip_dir/toolchain-requirements.txt"

# the whole prelude cannot be imported because it requires pyyaml to be
# installed, which happens just below.
. "$evergreen_dir/prelude_venv.sh"

activate_venv
echo "Upgrading pip to 21.0.1"

# ref: https://github.com/grpc/grpc/issues/25082#issuecomment-778392661
if [ "$(uname -m)" = "arm64" ] && [ "$(uname)" == "Darwin" ]; then
  export GRPC_PYTHON_BUILD_SYSTEM_OPENSSL=1
  export GRPC_PYTHON_BUILD_SYSTEM_ZLIB=1
fi

python -m pip --disable-pip-version-check install "pip==21.0.1" "wheel==0.37.0" || exit 1
python -m pip --disable-pip-version-check install -r "$toolchain_txt" -q --log install.log
if [ $? != 0 ]; then
  echo "Pip install error"
  cat install.log
  exit 1
fi
python -m pip freeze > pip-requirements.txt

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

# Move to the parent of the Evergreen workdir, which is where the virtualenv is extracted to.
cd ..

set -o errexit
set -o verbose

# Ignore Windows since it seems to work.
if [ "Windows_NT" = "$OS" ]; then
  exit 0
fi

cd mongodb-mongo-venv/bin/

rm python
ln -s "$python" python

pythons=$(ls python3*)
for p in $pythons; do
  rm "$p"
  ln -s python "$p"
done

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

cat << EOF > win_mount.sh
net use X: '\\\\${win_scons_endpoint}\\share' /USER:"wincache.build.com\\${win_scons_user}" '${win_scons_pass}'
EOF
chmod +x win_mount.sh

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit
set -o verbose
if [ "${use_wt_develop}" = "true" ]; then
  cd src/third_party
  for wtdir in dist examples ext lang src test tools; do
    rm -rf wiredtiger/$wtdir
    mv wtdevelop/$wtdir wiredtiger/
  done
fi

cd src

set -o errexit
set -o verbose

tag="$future_git_tag"
echo "TAG: $tag"
if [[ ! -z $tag ]]; then
  if [ "Windows_NT" = "$OS" ]; then
    # On Windows, we don't seem to have a local git identity, so we populate the config with this
    # dummy email and name. Without a configured email/name, the 'git tag' command will fail.
    git config user.email "no-reply@evergreen.@mongodb.com"
    git config user.name "Evergreen Agent"
  fi

  git tag -a $tag -m $tag
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o verbose
set -o errexit

git diff --name-only origin/${branch_name}... --line-prefix="${workdir}/src/" --diff-filter=d >> modified_and_created_patch_files.txt
if [ -d src/mongo/db/modules/enterprise ]; then
  pushd src/mongo/db/modules/enterprise
  git diff HEAD --name-only --line-prefix="${workdir}/src/src/mongo/db/modules/enterprise/" --diff-filter=d >> ~1/modified_and_created_patch_files.txt
  popd
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit
echo "const AWS_KMS_SECRET_ID = '${aws_kms_access_key_id}';" >> src/mongo/db/modules/enterprise/jstests/fle/lib/aws_secrets.js
echo "const AWS_KMS_SECRET_KEY = '${aws_kms_secret_access_key}';" >> src/mongo/db/modules/enterprise/jstests/fle/lib/aws_secrets.js

echo "const KMS_GCP_EMAIL = '${kms_gcp_email}'; " >> src/mongo/db/modules/enterprise/jstests/fle/lib/aws_secrets.js
echo "const KMS_GCP_PRIVATEKEY = '${kms_gcp_privatekey}'; " >> src/mongo/db/modules/enterprise/jstests/fle/lib/aws_secrets.js

echo "const KMS_AZURE_TENANT_ID = '${kms_azure_tenant_id}';" >> src/mongo/db/modules/enterprise/jstests/fle/lib/aws_secrets.js
echo "const KMS_AZURE_CLIENT_ID = '${kms_azure_client_id}';" >> src/mongo/db/modules/enterprise/jstests/fle/lib/aws_secrets.js
echo "const KMS_AZURE_CLIENT_SECRET = '${kms_azure_client_secret}';" >> src/mongo/db/modules/enterprise/jstests/fle/lib/aws_secrets.js

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

report_file="report.json"
# Check if the report file exists and has failures.
if [ -f $report_file ] && grep -Eq "\"failures\": [1-9]" $report_file; then
  # Calling the BF Suggestion server endpoint to start feature extraction.
  payload="{\"task_id\": \"${task_id}\", \"execution\": ${execution}}"
  echo "Sending task info to the BF suggestion service"
  # The --user option is passed through stdin to avoid showing in process list.
  user_option="--user ${bfsuggestion_user}:${bfsuggestion_password}"
  curl --header "Content-Type: application/json" \
    --data "$payload" \
    --max-time 10 \
    --silent \
    --show-error \
    --config - \
    https://bfsuggestion.corp.mongodb.com/tasks <<< $user_option
  echo "Request to BF Suggestion service status: $?"
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit
${decompress} mongo-binaries.tgz

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit
mongo_binary=dist-test/bin/mongo${exe}
activate_venv
bin_ver=$($python -c "import yaml; print(yaml.safe_load(open('compile_expansions.yml'))['version']);" | tr -d '[ \r\n]')
# Due to SERVER-23810, we cannot use $mongo_binary --quiet --nodb --eval "version();"
mongo_ver=$($mongo_binary --version | perl -pe '/version v([^\"]*)/; $_ = $1;' | tr -d '[ \r\n]')
# The versions must match
if [ "$bin_ver" != "$mongo_ver" ]; then
  echo "The mongo version is $mongo_ver, expected version is $bin_ver"
  exit 1
fi

set +o errexit

cd src
if [ -d "./build" ]; then
  file_list=$(find ./build -type f -name "*.gcda")
  if [ -n "$file_list" ]; then
    for gcda_file in $file_list; do
      echo "Processing file $gcda_file"
      /opt/mongodbtoolchain/v3/bin/gcov -i $gcda_file
      base_name=$(echo $gcda_file | rev | cut -f1 -d '/' | cut -f2 -d '.' | rev)
      gcov_file=$base_name.gcda.gcov
      if [ -f "$gcov_file" ]; then
        # Add a prefix to the intermediate file, since it does not have a unique name.
        # Convert the '/' to '#' in the file path.
        file_prefix=$(echo $gcda_file | sed -e 's,^\./,,' | rev | cut -f2- -d '/' | rev | tr -s '/' '#')
        new_gcov_file=$file_prefix #$base_name.gcda.gcov
        if [ ! -f $new_gcov_file ]; then
          echo "Renaming gcov intermediate file $gcov_file to $new_gcov_file"
          mv $gcov_file $new_gcov_file
        else
          # We treat this as a fatal condition and remove all of the coverage files.
          echo "Not renaming $gcov_file as $new_gcov_file already exists!"
          rm -f *.gcda.gcov
          exit 1
        fi
      fi
      rm $gcda_file
    done
  fi
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit
set -o verbose
# We get the raw version string (r1.2.3-45-gabcdef) from git
MONGO_VERSION=$(git describe --abbrev=7)
# If this is a patch build, we add the patch version id to the version string so we know
# this build was a patch, and which evergreen task it came from
if [ "${is_patch}" = "true" ]; then
  MONGO_VERSION="$MONGO_VERSION-patch-${version_id}"
fi
echo "MONGO_VERSION = ${MONGO_VERSION}"
activate_venv
# shared scons cache testing
# if 'scons_cache_scope' enabled and project level 'disable_shared_scons_cache' is not true
# 'scons_cache_scope' is set on a per variant basis
# 'disable_shared_scons_cache' is set on a project level and applies to all variants
# Shared - if scons_cache_scope is set, then use new shared scons cache settings
if [ ! -z ${scons_cache_scope} ]; then
  if [ "${disable_shared_scons_cache}" = "true" ]; then
    echo "SCons Cache disabled. All shared scons settings will be ignored"
    scons_cache_scope=none
  else
    scons_cache_scope=${scons_cache_scope}
  fi
  if [ "$scons_cache_scope" = "shared" ]; then
    set +o errexit
    if [ "Windows_NT" = "$OS" ]; then
      ./win_mount.sh
    else
      mount | grep "\/efs" > /dev/null
      if [ $? -eq 0 ]; then
        echo "Shared cache is already mounted"
      else
        echo "Shared cache - mounting file system"
        set_sudo
        $sudo mount /efs
      fi
    fi
    set -o errexit
  fi
  echo "Shared Cache with setting: ${scons_cache_scope}"
  MONGO_VERSION=$MONGO_VERSION SCONS_CACHE_MODE=${scons_cache_mode} SCONS_CACHE_SCOPE=$scons_cache_scope IS_PATCH=${is_patch} IS_COMMIT_QUEUE=${is_commit_queue} $python buildscripts/generate_compile_expansions_shared_cache.py --out compile_expansions.yml
# Legacy Expansion generation
else
  echo "Using legacy expansion generation"
  # Proceed with regular expansions generated
  # This script converts the generated version string into a sanitized version string for
  # use by scons and uploading artifacts as well as information about for the scons cache.
  MONGO_VERSION=$MONGO_VERSION SCONS_CACHE_MODE=${scons_cache_mode} USE_SCONS_CACHE=${use_scons_cache} $python buildscripts/generate_compile_expansions.py --out compile_expansions.yml
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

cat > mci.buildlogger << END_OF_CREDS
slavename='${slave}'
passwd='${passwd}'
builder='MCI_${build_variant}'
build_num=${builder_num}
build_phase='${task_name}_${execution}'
END_OF_CREDS

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

# Create the Evergreen API credentials
cat > .evergreen.yml << END_OF_CREDS
api_server_host: https://evergreen.mongodb.com/api
api_key: "${evergreen_api_key}"
user: "${evergreen_api_user}"
END_OF_CREDS

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

if [ -z "${files}" ]; then
  exit 0
fi
for file in ${files}; do
  if [ -f "$file" ]; then
    echo "Removing file $file"
    rm -f $file
  fi
done

cd src

if [ -d /data/thrift ]; then
  rm -rf /data/thrift
fi

if [ -d /data/charybdefs ]; then
  rm -rf /data/charybdefs
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o verbose
set -o errexit

# For patch builds gather the modified patch files.
if [ "${is_patch}" = "true" ]; then
  # Get list of patched files
  git diff HEAD --name-only >> patch_files.txt
  if [ -d src/mongo/db/modules/enterprise ]; then
    pushd src/mongo/db/modules/enterprise
    # Update the patch_files.txt in the mongo repo.
    git diff HEAD --name-only >> ~1/patch_files.txt
    popd
  fi
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit

cat << EOF > notary_env.sh
export NOTARY_TOKEN=${signing_auth_token_50}
export BARQUE_USERNAME=${barque_user}
export BARQUE_API_KEY=${barque_api_key}
EOF

echo "${signing_auth_token_50}" > signing_auth_token

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

proc_list="(java|lein|mongo|python|_test$|_test\.exe$)"
if [ "Windows_NT" = "$OS" ]; then
  get_pids() {
    proc_pids=$(tasklist /fo:csv \
      | awk -F'","' '{x=$1; gsub("\"","",x); print $2, x}' \
      | grep -iE $1 \
      | cut -f1 -d ' ')
  }
  get_process_info() {
    proc_name=""
    proc_info=$(wmic process where "ProcessId=\"$1\"" get "Name,ProcessId,ThreadCount" /format:csv 2> /dev/null | grep $1)
    if [ ! -z $proc_info ]; then
      proc_name=$(echo $proc_info | cut -f2 -d ',')
      proc_threads=$(echo $proc_info | cut -f4 -d ',')
    fi
  }
else
  get_pids() { proc_pids=$(pgrep $1); }
  get_process_info() {
    proc_name=$(ps -p $1 -o comm=)
    # /proc is available on Linux platforms
    if [ -f /proc/$1/status ]; then
      set_sudo
      proc_threads=$($sudo grep Threads /proc/$1/status | sed "s/\s//g" | cut -f2 -d ":")
    else
      proc_threads=$(ps -AM $1 | grep -vc PID)
    fi
  }
fi
while [ 1 ]; do
  get_pids $proc_list
  if [ ! -z "$proc_pids" ]; then
    printf "Running process/thread counter\n"
    printf "PROCESS\tPID\tTHREADS\n"
  fi
  for pid in $proc_pids; do
    get_process_info $pid
    if [ ! -z "$proc_name" ]; then
      printf "$proc_name\t$pid\t$proc_threads\n"
    fi
  done
  sleep 60
done

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

# Since the macros 'private_key_remote' and 'private_key_file' are not always defined
# we default to /dev/null to avoid syntax errors of an empty expansion.
if [ -n "$private_key_remote_bash_var" ]; then
  private_key_remote="$private_key_remote_bash_var"
fi
if [ ! -z "${private_key_remote}" ] && [ ! -z "${private_key_file}" ]; then
  mkdir -p ~/.ssh
  private_key_file=$(eval echo "$private_key_file")
  echo -n "${private_key_remote}" > ${private_key_file}
  chmod 0600 ${private_key_file}
fi

# Ensure a clean aws configuration state
rm -rf ~/.aws
mkdir -p ~/.aws

# If ${aws_profile_remote} is not specified then the config & credentials are
# stored in the 'default' profile.
aws_profile="${aws_profile_remote}"

# The profile in the config file is specified as [profile <profile>], except
# for [default], see http://boto3.readthedocs.io/en/latest/guide/configuration.html
if [ $aws_profile = "default" ]; then
  aws_profile_config="[default]"
else
  aws_profile_config="[profile $aws_profile]"
fi
cat << EOF >> ~/.aws/config
$aws_profile_config
region = us-east-1
EOF

# The profile in the credentials file is specified as [<profile>].
cat << EOF >> ~/.aws/credentials
[$aws_profile]
aws_access_key_id = ${aws_key_remote}
aws_secret_access_key = ${aws_secret_remote}
EOF

cat << EOF > ~/.boto
[Boto]
https_validate_certificates = False
EOF

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o verbose
set -o errexit

activate_venv
$python buildscripts/evergreen_resmoke_job_count.py \
  --taskName ${task_name} \
  --buildVariant ${build_variant} \
  --distro ${distro_id} \
  --jobFactor ${resmoke_jobs_factor} \
  --jobsMax ${resmoke_jobs_max} \
  --outFile resmoke_jobs_expansion.yml

set -o errexit
set -o verbose

# On Windows we can use typeperf.exe to dump performance counters.
if [ "Windows_NT" = "$OS" ]; then
  typeperf -qx PhysicalDisk | grep Disk | grep -v _Total > disk_counters.txt
  typeperf -cf disk_counters.txt -si 5 -o mongo-diskstats
# Linux: iostat -t option for timestamp.
elif iostat -tdmx > /dev/null 2>&1; then
  iostat -tdmx 5 > mongo-diskstats
# OSX: Simulate the iostat timestamp.
elif iostat -d > /dev/null 2>&1; then
  iostat -d -w 5 | while IFS= read -r line; do printf '%s %s\n' "$(date +'%m/%d/%Y %H:%M:%S')" "$line" >> mongo-diskstats; done
# Check if vmstat -t is available.
elif vmstat -td > /dev/null 2>&1; then
  vmstat -td 5 > mongo-diskstats
# Check if vmstat -T d is available.
elif vmstat -T d > /dev/null 2>&1; then
  vmstat -T d 5 > mongo-diskstats
else
  printf "Cannot collect mongo-diskstats on this platform\n"
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

# Create the Evergreen API credentials
cat > .selected_tests.yml << END_OF_CREDS
url: "https://selected-tests.server-tig.prod.corp.mongodb.com"
project: "${project}"
auth_user: "${selected_tests_auth_user}"
auth_token: "${selected_tests_auth_token}"
END_OF_CREDS

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit
set -o verbose
# removes files from the shared scons cache.

# Only prune on master branch
if [[ "${project}" == "mongodb-mongo-master" ]]; then

  set +o errexit

  if [ "Windows_NT" = "$OS" ]; then
    ./win_mount.sh
  else
    mount | grep "\/efs" > /dev/null
  fi
  if [ $? -eq 0 ]; then
    echo "Shared cache is already mounted"
  else
    echo "Shared cache - mounting file system"
    if [ "Windows_NT" = "$OS" ]; then
      ./win_mount.sh
    else
      sudo mount /efs
    fi
  fi
  set -o errexit

  if [ "Windows_NT" = "$OS" ]; then
    cache_folder=/cygdrive/x
  else
    cache_folder=/efs
  fi
  dirs=$(ls -l $cache_folder | grep -v total | awk '{print $NF}')

  echo "Pruning shared SCons directories"

  for dir in $dirs; do
    echo "Pruning $cache_folder/$dir/scons-cache"

    if [ -e $cache_folder/$dir/info/distro_name ]; then
      distro=$(cat $cache_folder/$dir/info/distro_name)
    fi

    # Set cache sizes by distro
    case $distro in
    ubuntu1604 | ubuntu1804 | rhel62 | rhel70)
      cache_size=600
      ;;
    *)
      # default
      cache_size=400
      ;;
    esac

    if [ "Windows_NT" = "$OS" ]; then
      echo "dir="$dir
      python buildscripts/scons_cache_prune.py --cache-dir x:/$dir/scons-cache --cache-size $cache_size --prune-ratio 1.0
    else
      sudo python buildscripts/scons_cache_prune.py --cache-dir /efs/$dir/scons-cache --cache-size $cache_size --prune-ratio 1.0
    fi
    echo ""
  done

  if [ "Windows_NT" = "$OS" ]; then
    net use X: /delete || true
  else
    sudo umount /efs || true
  fi

else
  echo "Not on master, shared SCons cache pruning skipped"
fi

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
. "$DIR/../prelude.sh"

cd src

set -o errexit
set -o verbose

if [ "${disable_shared_scons_cache}" = true ]; then
  exit
fi
if [ "${scons_cache_scope}" = "shared" ]; then
  if [ "Windows_NT" = "$OS" ]; then
    net use X: /delete || true
  else
    set_sudo
    $sudo umount /efs || true
  fi
fi
